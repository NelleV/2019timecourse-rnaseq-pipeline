---
title: "Normalization: A pipeline to analyse time-course gene expression data"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
---

```{r echo=FALSE, results="hide", message=FALSE}
# Loading dependencies
library(devtools)
library(limma)
library(splines)
library(stats)
library(moanin)
library(ggplot2)
library(stats)

source("utils.R")

# library(moanin)
```

```{r echo=FALSE}
# Set options
df = 6

# Preprocessing & filtering
is_count = FALSE
take_log = FALSE    
filter_expression = FALSE

# Differential expression analysis
timecourse_contrasts = c("C-K", "C-M")

# Clustering
filter_genes = TRUE
n_genes_to_keep = 5000
n_clusters = 20
percentage_genes_to_label = 0.5
```

```{r echo=FALSE, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  cache=FALSE, autodep=FALSE, warning=FALSE, error=FALSE, message=FALSE,
  echo=TRUE,
  duplicate.label="allow"
)

```


## Pre-processing and normalization

The micro-array data were obtained from NCBI Gene Expression Omnibus (GEO),
with accession number GSE63786. The dataset has a total of 209 samples, with
45018 probes (1 sample was removed by the authors prior to uploading the
dataset on GEO).

Note that in the following, we assume that the user has access to a data
folder `data/shoemaker2015/rawdata`, containing the microarray data. 

```{r}
data_dir = "data/shoemaker2015/rawdata"
```

Given the source and a `Targets.txt` structured as follows, microarray can be loaded thanks to the limma library.

```
FileName
GSM1557140_AR0313_043raw.txt.gz
GSM1557141_AR0313_044raw.txt.gz
GSM1557142_AR0313_045raw.txt.gz
GSM1557143_AR0313_055raw.txt.gz
GSM1557144_AR0313_056raw.txt.gz
GSM1557145_AR0313_057raw.txt.gz
GSM1557146_AR0313_058raw.txt.gz
GSM1557147_AR0313_059raw.txt.gz
```

```{r message=FALSE}
targets = limma::readTargets()
RG = limma::read.maimages(
  targets, source="agilent",
  path=data_dir,
  other.columns="gIsWellAboveBG",
  green.only=TRUE)

```

The normalization strategy we apply here relies on `limma` and is as follows:

  - First, normalize probe intensity using background information using the
    "norm-exponential" strategy.
  - Then normalize across micro-arrrays using quantile normalization.



```{r reading_targets, results="hide", fig.width=8, fig.height=4, message=FALSE}
# Perform background correction using norm-exponential strategy and normalize
# across samples using quantile normalization.
RG = limma::backgroundCorrect(RG, method="normexp")
RG.q = limma::normalizeBetweenArrays(RG, method="quantile")
```

Plotting the smoothed empirical densities of the probe values before
normalization shows considerable variations betweens arrays. Once the data has
been normalized across array using quantile normalization, the smoothed
empirical densities of each sample perfectly overlap.

```{r plotting_densities, results="hide", fig.width=8, fig.height=4}
# Plot the densities of the probes before and after normalization.
par(mfrow=c(1, 2))
limma::plotDensities(RG, col="black", legend=FALSE)
limma::plotDensities(RG.q, col="black", legend=FALSE)
```


```{r echo=FALSE, results="hide"}
# Get the number for the text. Do not display results or computation
control_probes = RG.q$genes[, "ControlType"] == 1
is_expressed = rowSums(RG.q$other$"gIsWellAboveBG" > 0) >= 4
n_control_probes = sum(control_probes)
n_lowly_expressed = sum(!is_expressed)
```

We then clean up the names of each gene and each sample to match the original
data. Finally, we further filter out probes based on the following criteria:
(1) removing the `r n_control_probes` control probes; (2) removing 
`r n_lowly_expressed` low-expressed genes. 

```{r clean_up_names}

sample_names = sapply(strsplit(colnames(RG.q), "_"), .subset2,  1)
colnames(RG.q) = sample_names
row.names(RG.q) = make.names(RG$genes$SystematicName, unique=TRUE)
idx_to_keep = which(
  !(RG$genes$Systematic %in% c("DarkCorner", "GE_BrightCorner",
			       "NegativeControl")))

data = RG.q[idx_to_keep,]

# Filter out control probes.
control_probes = data$genes[, "ControlType"] == 1
is_expressed = rowSums(data$other$"gIsWellAboveBG" > 0) >= 4

data = data[!control_probes & is_expressed, ]$E
```



```{r echo=FALSE, results="hide"}
# Do not display. setting variables for text
n_samples = dim(data)[2]
n_probes = dim(data)[1]
```

After filtering, we are left with `r n_probes` probes of interest in 
`r n_samples` samples.


Now that we have normalized and filtered the gene expressions, let's load the
metadata. The package `moanin` contains the normalized data and meta of
[@shoemaker:ultrasensitive].

```{r}
# Now load in the metadata
data(shoemaker2015)
meta = shoemaker2015$meta
```

```{r echo=FALSE, results="hide"}
write.table(data, ".results/quantile_normalized.txt")
```

## Exploratory analysis and quality control


Plotting the smoothed empirical densities of probe values for each sample and
estimating the variations across samples before and after normalization is a
first quality control step. Typically, two other quality control and
exploratory analysis steps are also performed before and after normalization:
(1) low dimensionality embedding of the samples; (2) correlation plots between
each samples. In both cases, we expect a strong biological signal, while
replicate samples should be strongly clustered or correlated with one another.


Before performing any additional exploratory analysis, let us only keep highly
variable genes: we keep for this step only the top 50% most variable genes.

```{r}
variance_cutoff = 0.5
variance_per_genes = apply(data, 1, mad)
min_variance = stats::quantile(variance_per_genes, c(variance_cutoff))
data = data[variance_per_genes > min_variance,]
```

```{r echo=FALSE, fig.width=8, fig.height=4}
graphics::hist(variance_per_genes, breaks=100, col="black", xlab="Variance",
	       ylab="# probes")
graphics::abline(v=min_variance, col="#AB0000", lw=2)
```

Let us first perform the PCA analysis. Here, we perform a PCA of rank 3 of the
centered and scaled gene expression data. 

```{r pca, fig.width=8, fig.height=8}
# Reorder genes on condition, time, and replicate

pca_data = stats::prcomp(t(data), rank=3, center=TRUE, scale=TRUE) 
percent_var = round(100 * attr(pca_data, "percentVar"))
```

We then plot the two first components, and color each sample by (1) its
condition; (2) its sampling time. We use different markers for each replicate.
We also plot the second and third components in the second row.

```{r pca_plots, fig.width=8, fig.height=8}
graphics::par(mfrow=c(2, 2))
graphics::plot(
    pca_data$x[, "PC2"], pca_data$x[, "PC1"],
    col=ann_colors$Group[meta$Group],
    pch=ann_markers$Replicate[as.factor(meta$Replicate)],
    xlab="PC2", ylab="PC1")
graphics::plot(
    pca_data$x[, "PC2"], pca_data$x[, "PC1"],
    col=ann_colors$Timepoint[as.factor(meta$Timepoint)],
    pch=ann_markers$Replicate[as.factor(meta$Replicate)],
    xlab="PC2", ylab="PC1")

graphics::plot(
    pca_data$x[, "PC2"], pca_data$x[, "PC3"],
    col=ann_colors$Group[meta$Group],
    pch=ann_markers$Replicate[as.factor(meta$Replicate)],
    xlab="PC2", ylab="PC3")
graphics::plot(
    pca_data$x[, "PC2"], pca_data$x[, "PC3"],
    col=ann_colors$Timepoint[as.factor(meta$Timepoint)],
    pch=ann_markers$Replicate[as.factor(meta$Replicate)],
    xlab="PC2", ylab="PC3")

```

Then, we plot the pearson correlation across each samples. We order the
samples by their Group (treatment) and Timepoint (the time of sampling).
Additionally, in this example, we order each treatment by strength of the
pathogenicity of the treatment: Control, Kawasaki, California, low dose of
Vietnam, then high dose of Vietnam.


```{r  correlation_plot, fig.width=6, fig.height=6}
library(NMF)

# Reorder the conditions such that:
#	- Control is before any influenza treatment
#	- Each treatment is ordered from low to high pathogeny
meta$Group = factor(meta$Group, levels(meta$Group)[c(3, 2, 1, 5, 4)])

# Reorder genes on condition, time, and replicate
ord = order(
  meta$Group,
  meta$Timepoint,
  meta$Replicate)
data = data[, ord]
meta = meta[ord, ]

data_corr = stats::cor(data, method="pearson")

meta$Timepoint = as.factor(meta$Timepoint)
NMF::aheatmap(
    data_corr,
    Colv=NA, Rowv=NA,
    annCol=meta[, c("Group", "Timepoint")],
    annRow=meta[, c("Group", "Timepoint")],
    annLegend=TRUE, 
    annColors=ann_colors,
    main="Correlation plot")
```

We can already see interesting patterns emerging from the correlation plot.
First, the cross-correlation amongst samples taking from the control mice is
higher than the cross correlation amongst the rest of the treatments. Second,
the influenza-infected mice midly react until time point 36. Third, the less
pathogenic the strain is, the closer the samples are to the control condition.
Fourth, the Vietnam samples at time point 120 and 168 are the one that are the
most different from control samples.

# References
