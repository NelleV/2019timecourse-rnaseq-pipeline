---
title: "Normalization: A pipeline to analyse time-course gene expression data"
output: rmarkdown::html_vignette
---

```{r echo=FALSE, results="hide"}
# Loading dependencies
library(devtools)
library(limma)
library(splines)
library(stats)
library(moanin)
source("utils.R")

# library(moanin)
```

```{r echo=FALSE}
# Set options
df = 6

# Preprocessing & filtering
is_count = FALSE
take_log = FALSE    
filter_expression = FALSE

# Differential expression analysis
timecourse_contrasts = c("C-K", "C-M")

# Clustering
filter_genes = TRUE
n_genes_to_keep = 5000
n_clusters = 20
percentage_genes_to_label = 0.5
```

```{r echo=FALSE, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  cache=FALSE, autodep=FALSE, warning=FALSE, error=FALSE, message=FALSE,
  echo=TRUE,
  duplicate.label="allow"
)

library(genefilter)
library(dplyr)
library(ggplot2)
library(NMF)
library(reshape2)
library(limma)
```


## Pre-processing

The micro-array data were obtained from NCBI Gene Expression Omnibus (GEO),
with accession number GSE63786. The dataset has a total of 209 samples, with
45018 probes.

Note that in the following, we assume that the user has access to a data
folder `data/shoemaker2015/rawdata`, containing the microarray data. 

```{r}
data_dir = "data/shoemaker2015/rawdata"
```

The normalization strategy we apply here relies on `limma` and is as follows:

  - First, normalize probe intensity using background information using the
    "norm-exponential" strategy.
  - Then normalize across micro-arrrays using quantile normalization.



```{r reading_targets, results="hide", fig.width=8, fig.height=8}
# Read in the data using limma.
targets = limma::readTargets()
RG = limma::read.maimages(
  targets, source="agilent",
  path=data_dir,
  other.columns="gIsWellAboveBG",
  green.only=TRUE)

# Preform background correction using norm-exponential strategy and normalize
# across samples using quantile normalization.
RG = backgroundCorrect(RG, method="normexp")
RG.q = normalizeBetweenArrays(RG, method="quantile")

# Plot the densities of the probes before and after normalization.
par(mfrow=c(1, 2))
plotDensities(RG, col="black", legend=FALSE)
plotDensities(RG.q, col="black", legend=FALSE)
```


```{r echo=FALSE, results="hide"}
# Get the number for the text. Do not display results or computation
control_probes = RG.q$genes[, "ControlType"] == 1
is_expressed = rowSums(RG.q$other$"gIsWellAboveBG" > 0) >= 4
n_control_probes = sum(control_probes)
n_lowly_expressed = sum(!is_expressed)
```

We then clean up the names of each gene and each sample to match the original
data. Finally, we further filter out probes based on the following criteria:
(1) removing the `r n_control_probes` control probes; (2) removing `r
n_lowly_expressed` low-expressed genes. 

```{r clean_up_names}

sample_names = sapply(strsplit(colnames(RG.q), "_"), .subset2,  1)
colnames(RG.q) = sample_names
row.names(RG.q) = make.names(RG$genes$SystematicName, unique=TRUE)
idx_to_keep = which(
  !(RG$genes$Systematic %in% c("DarkCorner", "GE_BrightCorner",
			       "NegativeControl")))

data = RG.q[idx_to_keep,]

# Filter out control probes.
control_probes = data$genes[, "ControlType"] == 1
is_expressed = rowSums(data$other$"gIsWellAboveBG" > 0) >= 4

data = data[!control_probes & is_expressed, ]$E
```

 XXX The original paper says the data is "averaged over unique probes IDs."


```{r echo=FALSE, results="hide"}
# Do not display. setting variables for text
n_samples = dim(data)[2]
n_probes = dim(data)[1]
```

After filtering, we are left with `r n_probes` probes of interest in `r
n_samples`.


```{r}

# Now load in the metadata
meta = read.delim("data/shoemaker2015/mice_meta.tsv", sep="\t")
write.table(data, ".results/quantile_normalized.txt")
```

```{r order_genes, fig.width=8, fig.height=4}
# Reorder genes on condition, time, and replicate

library(ggfortify)
pca_data = prcomp(t(data), rank=5, center=TRUE, scale=TRUE) 
percent_var = round(100 * attr(pca_data, "percentVar"))

# FIXME Add legend
par(mfrow=c(1, 2))
plot(pca_data$x[, "PC1"], pca_data$x[, "PC2"],
     col=ann_colors$Group[meta$Group], pch=16, xlab="PC1", ylab="PC2")
plot(pca_data$x[, "PC1"], pca_data$x[, "PC2"],
     col=ann_colors$Time[meta$Time], pch=16, xlab="PC1", ylab="PC2")

```

We then plot the correlation matrix

```{r fig.width=6, fig.height=6}
library(NMF)

# Reorder genes on condition, time, and replicate
ord = order(
  meta$Group,
  meta$Time,
  meta$Replicate)
data = data[, ord]
meta = meta[ord, ]

data_corr = cor(data, method="pearson")
aheatmap(data_corr,
         Colv=NA, Rowv=NA,
         annCol=meta[,
		     c("Group", "Time",
			"Replicate")],
         annLegend=FALSE, 
	 annColors=ann_colors,
         main="Correlation plot after Normalization")
```


## Structure of the data set

```{r}
```
