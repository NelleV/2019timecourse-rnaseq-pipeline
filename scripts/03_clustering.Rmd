---
title: "Clustering: A pipeline to analyse time-course gene expression data"
output: rmarkdown::html_vignette
---


```{r echo=FALSE, results="hide"}
# Loading dependencies
library(devtools)
library(limma)
library(splines)
library(stats)
library(moanin)
source("utils.R")
# library(moanin)
```

```{r echo=FALSE, results="hide"}
# Set options
df = 6

# Preprocessing & filtering
is_count = FALSE
take_log = FALSE    
filter_expression = FALSE

###############################################################################
# Clustering

# Whether to filter genes
filter_genes = TRUE
keep_all_significant = FALSE
n_genes_to_keep = 10000
n_clusters = 20
percentage_genes_to_label = 0.5
```

```{r echo=FALSE, results="hide"}
# Set data files and options
data("shoemaker2015")

data = shoemaker2015$data
meta = shoemaker2015$meta

data = read.table(".results/quantile_normalized.txt") 

# Right now, the package doesn't contain the normalized data
de_analysis = read.table(".results/pvalues.txt", sep="\t", check.names=FALSE)
```

# Clustering of time-course data

The next step is to perform clustering.

```{r filter_genes}
if(filter_genes){
    # First, filter out any genes that doesn't have a log fold change of at
    # least 2 at at least one of the time points.
    lfc_col_to_keep = colnames(de_analysis)[
	grepl("-lfc_max", colnames(de_analysis))]
    de_analysis = de_analysis[rowSums(abs(de_analysis[, lfc_col_to_keep]) > 2) > 0, ]

    if(dim(de_analysis)[1] > n_genes_to_keep){

	# Then rank by fisher's p-value and take max the number of genes of
	# interest
	# Filter out q-values for the pvalues table
	pval_col_to_keep = colnames(de_analysis)[grepl("-pval", colnames(de_analysis))]
	pvalues = de_analysis[, pval_col_to_keep]
	fishers_pval = moanin:::fisher_method(pvalues)
	fishers_qval = stats::p.adjust(fishers_pval)
        if(keep_all_significant){
	   genes_to_keep = names(fishers_qval[fishers_qval < 0.05])
	}else{
	    genes_to_keep = names(sort(fishers_pval)[1:n_genes_to_keep])
	}
    }else{
	genes_to_keep = names(pvalues)
    }

    y = as.matrix(data[genes_to_keep, ])
}else{
    y = as.matrix(data)
}
```

After filtering, we consider `r dim(y)[1]` genes for the clustering.

```{r clustering}

#############################################################################
# Fit the splines


kmeans_clusters = moanin:::splines_kmeans(
    y, meta, n_clusters=20,
    random_seed=42,
    n_init=20,
    degrees_of_freedom=df)

# Rescale the centroids
centroids = moanin:::rescale_values(kmeans_clusters$centroids, meta)
all_scores = data.frame(row.names=row.names(data))
for(k in 1:n_clusters){
    scores = moanin:::score_genes_centroid(data, centroids[k,])
    all_scores[paste0("cluster_", k)] = scores
}

# Only assign labels to X% of the genes
max_score = quantile(moanin:::row_min(all_scores), c(percentage_genes_to_label))
genes_to_not_consider = moanin:::row_min(all_scores) >= max_score
labels = moanin:::row_argmin(all_scores)
labels[genes_to_not_consider] = NA
```

```{r}
table(kmeans_clusters$clusters)
```

```{r}
table(labels)
```


```{r fig.height=8, fig.width=8}
moanin:::plot_centroids(centroids, meta,
			colors=as.vector(unlist(ann_colors["Group"])))
```

```{r results="hide", echo=FALSE}
# Save the clustering for the next step
kmeans_labels = as.data.frame(kmeans_clusters$clusters)
row.names(kmeans_labels) = row.names(y)
write.table(kmeans_labels,
	    ".results/clustering_labels.txt",
	    sep="\t")
```
